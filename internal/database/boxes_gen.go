//this file was generated by Robots, Don't Edit!!!!!!
package database

import (
	"errors"
	"golayout/pkg/logger"
	"time"
)

type BoxesKindStateType string
type BoxesStateType string

type Boxes struct {
	Id        uint64             `db:"id" json:"id"`                 //id NULL:NO Default:NULL
	Level     int                `db:"level" json:"level"`           //level NULL:NO Default:NULL
	KindState BoxesKindStateType `db:"kind_state" json:"kind_state"` //kind_state NULL:NO Default:NULL
	KindId    uint64             `db:"kind_id" json:"kind_id"`       //kind_id NULL:NO Default:NULL
	State     BoxesStateType     `db:"state" json:"state"`           //state NULL:NO Default:NULL
	UpdatedAt time.Time          `db:"updated_at" json:"updated_at"` //updated_at NULL:NO Default:NULL
	CreatedAt time.Time          `db:"created_at" json:"created_at"` //created_at NULL:NO Default:NULL
	deleted   bool               `db:"-"`
}

func (b Boxes) TableName() string {
	return "boxes"
}

func (b *Boxes) Exists() bool {
	return b.Id != 0
}

func (b *Boxes) IsDeleted() bool {
	return b.deleted
}

func GetBoxesById(id uint64) (*Boxes, error) {
	var b Boxes
	err := db.Select(&b, "SELECT * FROM boxes where id = ?", id)
	if err != nil {
		logger.Error(err)
	}
	return &b, err
}

//getBoxesBy Write your own sql in another function
func getBoxesBy(sqlStr string, args ...interface{}) ([]*Boxes, error) {
	var (
		bs  []*Boxes
		err error
	)
	err = db.Select(&bs, sqlStr, args...)
	if err != nil {
		logger.Error(err)
	}
	return bs, err
}

func (b *Boxes) Insert() error {
	var err error
	if b.Exists() {
		return errors.New("insert failed: already exists")
	}
	b.CreatedAt = time.Now()
	b.UpdatedAt = b.CreatedAt
	//sql query
	const sqlstr = `
		INSERT INTO boxes (level,kind_state,kind_id,state,updated_at,created_at) VALUES (:level,:kind_state,:kind_id,:state,:updated_at,:created_at)
	`
	tx := db.MustBegin()
	result, err := tx.NamedExec(sqlstr, b)
	if err != nil {
		tx.Rollback()
	} else {
		err = tx.Commit()
	}
	if err != nil {
		logger.Error(err)
		return err
	}

	newID, err := result.LastInsertId()
	if err != nil {
		return err
	}

	b.Id = uint64(newID)

	return nil
}

func (b *Boxes) Drop() error {
	if !b.Exists() {
		return errors.New("Delete failed: does not exists")
	}

	if b.deleted {
		return nil
	}

	const sqlstr = `
		DELETE FROM boxes where id= ?
	`
	tx := db.MustBegin()
	_, err := tx.Queryx(sqlstr, &b.Id)
	if err != nil {
		logger.Error(err)
		return tx.Rollback()
	}

	if err = tx.Commit(); err != nil {
		logger.Error(err)
		return err
	}
	b.deleted = true

	return nil
}

//UPdate Warning!!! this function will update all fields
func (b Boxes) Update() error {
	const sqlstr = `
		UPDATE boxes SET level=:level,kind_state=:kind_state,kind_id=:kind_id,state=:state,updated_at=:updated_at,created_at=:created_at where id = ?
	`

	tx := db.MustBegin()
	_, err := tx.Queryx(sqlstr, &b.Id)
	if err != nil {
		logger.Error(err)
		return tx.Rollback()
	}

	if err = tx.Commit(); err != nil {
		logger.Error(err)
		return err
	}
	return nil
}
